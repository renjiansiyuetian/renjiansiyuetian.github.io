<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lotus&#39;s Blog</title>
  
  <subtitle>既来之，则安之</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://renjiansiyuetian.github.io/"/>
  <updated>2018-10-30T04:35:27.610Z</updated>
  <id>https://renjiansiyuetian.github.io/</id>
  
  <author>
    <name>wangHianHui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js-es6 经常使用</title>
    <link href="https://renjiansiyuetian.github.io/2019/01/05/js-es6%20%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8/"/>
    <id>https://renjiansiyuetian.github.io/2019/01/05/js-es6 经常使用/</id>
    <published>2019-01-04T16:00:00.000Z</published>
    <updated>2018-10-30T04:35:27.610Z</updated>
    
    <content type="html"><![CDATA[<p> 对象解包</p><blockquote><p>const {a, b} = obj<br>直接能用变量a、b</p></blockquote><hr><p>数组解包</p><blockquote><p>[…state.cart.added]</p></blockquote><hr><p>async -&gt;await-&gt;Promise</p><hr><p>es6 的``</p><blockquote><p>要用一堆的’+’号来连接文本与变量，而使用ES6的新特性模板字符串``后，例如:</p></blockquote>&lt;Link to={`/taco/${taco.name}`}&gt;{taco.name}<hr><p>es6对象解构</p><blockquote><p>let cat = ‘ken’<br>let dog = ‘lili’<br>let zoo = {cat, dog} 等价于 {cat: cat, dog: dog}<br>相反可以写为:<br>let dog = {type: ‘animal’, many: 2}<br>let { type, many} = dog</p></blockquote><hr><p>… 的使用</p><blockquote><p>function animals(…types){<br>    console.log(types)<br>}<br>animals(‘cat’, ‘dog’, ‘fish’) //[“cat”, “dog”, “fish”]</p></blockquote><hr><p>es6 文件以及文件里的函数 引入引出</p><blockquote><p>//index.js<br>import animal from ‘./content’<br>//content.js<br>export default ‘A cat’</p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 对象解包&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;const {a, b} = obj&lt;br&gt;直接能用变量a、b&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;数组解包&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[…state.cart.added]&lt;/p&gt;
&lt;/bl
      
    
    </summary>
    
      <category term="es6" scheme="https://renjiansiyuetian.github.io/categories/es6/"/>
    
    
      <category term="es6" scheme="https://renjiansiyuetian.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>git</title>
    <link href="https://renjiansiyuetian.github.io/2018/11/28/git/"/>
    <id>https://renjiansiyuetian.github.io/2018/11/28/git/</id>
    <published>2018-11-27T16:00:00.000Z</published>
    <updated>2018-10-30T04:26:21.327Z</updated>
    
    <content type="html"><![CDATA[<p>1、npm与yarn常用命令对比<br><a id="more"></a><br> <img src="/img/yarn-npm.jpg" alt="yarn-npm" title="yarn-npm"></p><p>2、git 撤销</p><blockquote><p>git reflog (可以查看所有分支的所有操作记录（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录)<br>git reset –hard (commit id) 回退到某版本<br>git push origin (branch) 提交到远端</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、npm与yarn常用命令对比&lt;br&gt;
    
    </summary>
    
      <category term="git" scheme="https://renjiansiyuetian.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://renjiansiyuetian.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>js项目小记录</title>
    <link href="https://renjiansiyuetian.github.io/2018/08/12/js%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0%E5%BD%95/"/>
    <id>https://renjiansiyuetian.github.io/2018/08/12/js项目小记录/</id>
    <published>2018-08-11T16:00:00.000Z</published>
    <updated>2018-10-30T04:21:10.895Z</updated>
    
    <content type="html"><![CDATA[<p>1、a标签上的，防止链接被随意修改而改变了跳转地址。</p><blockquote><p>rel=”noreferrer” rel=”noopener”  可合并为：<br>rel=”noopener noreferrer” /// a标签上的，防止链接被随意修改而改变了跳转地址。<br>在跳转到第三方网站的时候，为了 SEO 权重，还建议带上 rel=”nofollow”:<br>rel=”noopener noreferrer nofollow”<br>{ 如果网站使用了 <a target="_blank">，那么新打开的标签页的性能将会影响到当前页面。此时如果新打开的页面中执行了一个非常庞大的 JavaScript 脚本，那么原始标签页也会受到影响，会出现卡顿的现象（当然不至于卡死）。<br>而如果在链接中加入了 noopener，则此时两个标签页将会互不干扰，使得原页面的性能不会受到新页面的影响。}</a></p></blockquote><blockquote><p>为了保护稍旧的“近代”浏览器或是很旧的“古代”浏览器甚至是“远古”浏览器，只有 noopener 属性还是远远不够的:<br>“use strict”;<br>function openUrl(url) {<br>  var newTab = window.open();<br>  newTab.opener = null;<br>  newTab.location = url;<br>}</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、a标签上的，防止链接被随意修改而改变了跳转地址。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;rel=”noreferrer” rel=”noopener”  可合并为：&lt;br&gt;rel=”noopener noreferrer” /// a标签上的，防止链接被随意修改而改变
      
    
    </summary>
    
      <category term="js" scheme="https://renjiansiyuetian.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://renjiansiyuetian.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>mac破解webstorm2018.15</title>
    <link href="https://renjiansiyuetian.github.io/2018/05/16/mac%E7%A0%B4%E8%A7%A3webstorm2018.15/"/>
    <id>https://renjiansiyuetian.github.io/2018/05/16/mac破解webstorm2018.15/</id>
    <published>2018-05-15T16:00:00.000Z</published>
    <updated>2018-10-30T03:54:26.431Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>1、先下载网上的此软件进行安装。<br>  2、安装完毕后，在终端输入”sudo vim /etc/hosts”,对hosts进行编辑。<br> 3、在终端进入hosts得编辑模式，在最后一行加上”0.0.0.0 account.jetbrains.com”,完毕后保存退出即可。<br>4、打开网站<a href="http://idea.lanyus.com/，点击获取注册码，先复制获得的注册码。然后打开webstorm软件，点击help/帮助，进入register/注册页面，选择Activation" target="_blank" rel="noopener">http://idea.lanyus.com/，点击获取注册码，先复制获得的注册码。然后打开webstorm软件，点击help/帮助，进入register/注册页面，选择Activation</a> code选项并将复制内容粘贴在其下的方框中，点击OK即可。如果在软件的右下角弹出Registration Your copy is licensed to lan yu便是注册破解成功了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;1、先下载网上的此软件进行安装。&lt;br&gt;  2、安装完毕后，在终端输入”sudo vim /etc/hosts”,对hosts进行编辑。&lt;br&gt; 3、在终端进入hosts得编辑模式，在最后一行加上”0.0.0.0 account.jetbrains
      
    
    </summary>
    
      <category term="webstorm" scheme="https://renjiansiyuetian.github.io/categories/webstorm/"/>
    
    
      <category term="webstorm2018.15" scheme="https://renjiansiyuetian.github.io/tags/webstorm2018-15/"/>
    
  </entry>
  
  <entry>
    <title>css 问题小记录</title>
    <link href="https://renjiansiyuetian.github.io/2018/02/22/css-%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0%E5%BD%95/"/>
    <id>https://renjiansiyuetian.github.io/2018/02/22/css-问题小记录/</id>
    <published>2018-02-21T16:00:00.000Z</published>
    <updated>2018-10-30T03:51:47.238Z</updated>
    
    <content type="html"><![CDATA[<p>解决h5页面在ios上卡顿:</p><blockquote><p>在总的css控制里添加： *{<br>  -webkit-overflow-scrolling: touch;<br>  }</p></blockquote><hr><p>通过媒体查询可以为不同大小和尺寸的媒体定义不同的css，适应相应的设备的显示。</p><blockquote><ol><li><head><meta name="generator" content="Hexo 3.8.0">里边&lt;link rel=”stylesheet” type=”text/css” href=”xxx.css” media=”only screen and (max-device-width:480px)”&gt;</head></li><li>CSS : @media only screen and (max-device-width:480px) {/css样式/}</li></ol></blockquote><hr><p>伪类(:)的操作对象是文档树中已有的元素，而伪元素(::)则创建了一个文档数外的元素。</p><hr><p>让页面里的字体变清晰，变细用CSS怎么做？</p><blockquote><p>-webkit-font-smoothing在window系统下没有起作用，但是在IOS设备上起作用-webkit-font-smoothing：antialiased是最佳的，灰度平滑。</p></blockquote><hr><p>position:fixed;在android下无效怎么处理?</p><blockquote><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"></blockquote><hr><p>png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？</p><blockquote><ol><li>png是便携式网络图片（Portable Network Graphics）是一种无损数据压缩位图文件格式.优点是：压缩比高，色彩好。 大多数地方都可以用。</li><li>jpg是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在www上，被用来储存和传输照片的格式。</li><li>gif是一种位图文件格式，以8位色重现真色彩的图像。可以实现动画效果.</li><li>webp格式是谷歌在2010年推出的图片格式，压缩率只有jpg的2/3，大小比png小了45%。缺点是压缩的时间更久了，兼容性不好，目前谷歌和opera支持。</li></ol></blockquote><hr><p>关于目前的仿原生开发<br><a id="more"></a><br> <img src="/img/native.jpg" alt="2018年末总结的仿原生开发的问题" title="2018年末总结的仿原生开发的问题"></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解决h5页面在ios上卡顿:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在总的css控制里添加： *{&lt;br&gt;  -webkit-overflow-scrolling: touch;&lt;br&gt;  }&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;通过媒体查询可以为不同大小和尺寸的媒体定义不同的css，适应相应的设备的显示。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;head&gt;&lt;meta name=&quot;generator&quot; content=&quot;Hexo 3.8.0&quot;&gt;里边&amp;lt;link rel=”stylesheet” type=”text/css” href=”xxx.css” media=”only screen and (max-device-width:480px)”&amp;gt;&lt;/head&gt;&lt;/li&gt;
&lt;li&gt;CSS : @media only screen and (max-device-width:480px) {/css样式/}&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;伪类(:)的操作对象是文档树中已有的元素，而伪元素(::)则创建了一个文档数外的元素。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;让页面里的字体变清晰，变细用CSS怎么做？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-webkit-font-smoothing在window系统下没有起作用，但是在IOS设备上起作用-webkit-font-smoothing：antialiased是最佳的，灰度平滑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;position:fixed;在android下无效怎么处理?&lt;/p&gt;
&lt;blockquote&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;png是便携式网络图片（Portable Network Graphics）是一种无损数据压缩位图文件格式.优点是：压缩比高，色彩好。 大多数地方都可以用。&lt;/li&gt;
&lt;li&gt;jpg是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在www上，被用来储存和传输照片的格式。&lt;/li&gt;
&lt;li&gt;gif是一种位图文件格式，以8位色重现真色彩的图像。可以实现动画效果.&lt;/li&gt;
&lt;li&gt;webp格式是谷歌在2010年推出的图片格式，压缩率只有jpg的2/3，大小比png小了45%。缺点是压缩的时间更久了，兼容性不好，目前谷歌和opera支持。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;关于目前的仿原生开发&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="https://renjiansiyuetian.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://renjiansiyuetian.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>vue 项目遇到问题小结</title>
    <link href="https://renjiansiyuetian.github.io/2018/01/16/vue%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93/"/>
    <id>https://renjiansiyuetian.github.io/2018/01/16/vue项目遇到问题小结/</id>
    <published>2018-01-15T16:00:00.000Z</published>
    <updated>2018-10-29T10:22:30.933Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue问题小结"><a href="#vue问题小结" class="headerlink" title="vue问题小结"></a>vue问题小结</h3><p>1）引入全局的scss（一般在app.vue里引入），其中若涉及@mixin 与 @include，样式不起作用。<br>2）布局样式重置全局样式，无效，必须去掉scoped。<br>3）将ui框架组件集合在一起全局声明。<br>4）v-for 报错，解决方式: 加上属性:key=“item.id”便可。<br>5）兄弟组件之间调用函数：</p><blockquote><p>在离开页面时执行并解除绑定<br>beforeDestroy: function () {<br>this.$off(‘updateProfile’, this.updateProfile())<br>}<br>在离开页面时，获取从哪来到哪去<br>beforeRouteLeave: function (to, from, next) {<br>if (to.name !== ‘BalanceHistory’) {<br>localStorage.removeItem(‘query’)<br>}<br>next()<br>},</p></blockquote><p>6）watch里面 es6语法不能用（2017年时候）。<br>7）新的2.0循环</p><blockquote><p>新数组语法<br>value in arr<br>(value, index) in arr<br>新对象语法<br>value in obj<br>(value, key) in obj<br>(value, key, index) in obj</p></blockquote><p>8）vue循环过滤</p><blockquote><p>v-for=”val in arr | limitBy 2” 在2.0之后不能再用，<br>用computed代替：<br>computed: {<br>filteredItems: function () {<br>return this.items.slice(0, 10)<br>}<br>}<br>v-for=”val in filteredItems”</p></blockquote><p>9）$set</p><blockquote><p>在js中是这样 arr[id] = value, 这样便完成了可以通过下标设置值。<br>但是在vue中，这样虽然也可以，但是其后期值得变化更新是不会同步到dom上的，<br>所以，需用此代替:<br>this.$set(this.arr, id, value)。其中,this为vue对象。<br>官方文档是如此介绍：<br>vue-set设置对象的属性。如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法主要用于避开 Vue 不能检测属性被添加的限制。</p></blockquote><p>10）页面传值</p><blockquote><p>赋值:this.$router.push({ name: ‘xx’, query: this.q })<br>接收：if(Object.keys(this.$route.query).length &gt; 0) {<br>this.q = this.$route.query<br>}</p></blockquote><p>11）vue中通过$ref操作dom</p><ul><li>例如:<pre><code>&lt;ul&gt;  &lt;li ref=“li”&gt;&lt;/li&gt;  &lt;li ref=“li”&gt;&lt;/li&gt;  &lt;li ref=“li”&gt;&lt;/li&gt;&lt;/ul&gt;则加class li样式时，则可以如此(注意li上的id是唯一的):changeItem (ob) {  this.$refs.li.forEach((item, index) =&gt; {    if (this.$refs.li[index].id === ob.target.id) {      this.$refs.li[index].className = &apos;li&apos;    } else {      this.$refs.li[index].className = &apos;&apos;    }  })} </code></pre>12）在子组件中修改父组件的值<blockquote><p>父组件中:</p><pre><code>&lt;select-option class=”bottom” :banks=”banks” :currentBank.sync=“currentBank”&gt;&lt;/select-option&gt;</code></pre><p>注意父组件中的sync后带着的变量currentBank。<br>——————————————————————————————————————<br>子组件中:<br>在子组件里可以如此去修改currentBank的值:</p><pre><code>this.$emit(‘update:currentBank’, item)</code></pre></blockquote></li></ul><p>13）mode为history，刷新失效</p><ul><li>mode: ‘history’,<br>可以使路由去掉#，但是会使本路由刷新(比如本路由的参数变化时，理想情况是本页面数据也变化)失效。<br>解决方法: 在对应的router-view上加key：        <pre><code>&lt;router-view :key=“routeKey&quot;&gt;&lt;/router-view&gt;computed: { routeKey () {  return `${this.$route.path}` }},</code></pre></li></ul><p>14）页面数据不刷新</p><blockquote><p>当你设置 vm.someData = ‘new value’ ，该组件不会立即重新渲染。可以在数据变化之后立即使用 Vue.nextTick(callback)。</p></blockquote><p>15）组件</p><blockquote><p>Vue 组件的 API 来自三部分 - props, events 和 slots ：<br>Props 允许外部环境传递数据给组件<br>Events 允许组件触发外部环境的副作用<br>Slots 允许外部环境将额外的内容组合在组件中。</p></blockquote><p>16）Vuex</p><blockquote><p>1、在使用store时，尽量用commit来触发mutation达到改变state数据的目的。<br>2、通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。<br>3、在组件中使用 this.$store.dispatch(‘xxx’) 分发 action。    </p></blockquote><p>17) 数据渲染</p><blockquote><p>初始化数据时，用mounted钩子，但不能保证实例已经插入到文档，所以在钩子函数里包含 Vue.nextTick():<br>mounted: function () {<br>this.$nextTick(function(){<br>//保证this.$el已经插入文档<br>})<br>}</p></blockquote><p>18)其它vue问题小结（某位同学的）<br><a href="https://segmentfault.com/a/1190000005832164" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005832164</a><br><a href="http://web.jobbole.com/93298/" target="_blank" rel="noopener">http://web.jobbole.com/93298/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;vue问题小结&quot;&gt;&lt;a href=&quot;#vue问题小结&quot; class=&quot;headerlink&quot; title=&quot;vue问题小结&quot;&gt;&lt;/a&gt;vue问题小结&lt;/h3&gt;&lt;p&gt;1）引入全局的scss（一般在app.vue里引入），其中若涉及@mixin 与 @include，
      
    
    </summary>
    
      <category term="vue" scheme="https://renjiansiyuetian.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://renjiansiyuetian.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue之小功能记录</title>
    <link href="https://renjiansiyuetian.github.io/2017/12/20/vue%E4%B9%8B%E5%B0%8F%E5%8A%9F%E8%83%BD%E8%AE%B0%E5%BD%95/"/>
    <id>https://renjiansiyuetian.github.io/2017/12/20/vue之小功能记录/</id>
    <published>2017-12-19T16:00:00.000Z</published>
    <updated>2018-10-30T02:06:55.528Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、滚动展示字"><a href="#一、滚动展示字" class="headerlink" title="一、滚动展示字"></a>一、滚动展示字</h3><blockquote><p>1）得知目前所有文字区域（包含隐藏起来的区域）的高度（clientHeight），减去展现出来的区域(以下以father称呼)高度，得文字的滚动区域（以下以scrollContent称呼）高度。<br>2) 将滚动区域scrollContent的设置为absolute，将展现出来的区域father设置为relative，通过计时器setInterval一定时间内挪动一定的距离便可。</p></blockquote><ul><li>参考代码如下：<pre><code>bind: (el) =&gt; {    Vue.nextTick(() =&gt; {    // bind 为自定义指令时的触发信号之一（ 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作）。nextTick()函数为该页面数据渲染完毕后执行，这样就可以得到真是的文字(后台返回)高度。          let scrollTop = el.clientHeight - 200 // 200为父亲高度，如此得滚动区域(scrollContent)高度          let tempTop = 0          function getInterval () {            el.intervalTime = setInterval(() =&gt; {              tempTop = -1 + tempTop // 1px为每次移动距离，如此计算为总的移动距离              if (-tempTop &gt; scrollTop) {                el.style.top = 0 + &apos;px&apos;                tempTop = 0              } else { // 执行条件为总的移动距离 小于 滚动区域(scrollContent)高度                el.style.top = tempTop + &apos;px&apos;              }            }, 50)          }          el.addEventListener(&apos;touchstart&apos;, () =&gt; { // 监听关闭            window.clearInterval(el.intervalTime)            el.intervalTime = null          })          el.addEventListener(&apos;touchend&apos;, () =&gt; { // 监听再次开启            if (el.intervalTime !== null) {              return            }            getInterval()          })         // end        })      }    </code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、滚动展示字&quot;&gt;&lt;a href=&quot;#一、滚动展示字&quot; class=&quot;headerlink&quot; title=&quot;一、滚动展示字&quot;&gt;&lt;/a&gt;一、滚动展示字&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;1）得知目前所有文字区域（包含隐藏起来的区域）的高度（clientHeig
      
    
    </summary>
    
      <category term="vue" scheme="https://renjiansiyuetian.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://renjiansiyuetian.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue项目搭建</title>
    <link href="https://renjiansiyuetian.github.io/2017/11/01/vue%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
    <id>https://renjiansiyuetian.github.io/2017/11/01/vue项目搭建/</id>
    <published>2017-10-31T16:00:00.000Z</published>
    <updated>2018-10-30T02:17:38.562Z</updated>
    
    <content type="html"><![CDATA[<h3 id="插件结合搭建vue项目"><a href="#插件结合搭建vue项目" class="headerlink" title="插件结合搭建vue项目"></a>插件结合搭建vue项目</h3><p>1) axios: <a href="https://github.com/superman66/vue-axios-github" target="_blank" rel="noopener">https://github.com/superman66/vue-axios-github</a><br>2) 基于 vue + element-ui 的后台管理系统: <a href="https://github.com/bailicangdu/vue2-manage" target="_blank" rel="noopener">https://github.com/bailicangdu/vue2-manage</a><br>3) 基于vue+vue-router+vuex+axios+webpack开发的个人Demo:<a href="https://github.com/hzzly/xyy-vue" target="_blank" rel="noopener">https://github.com/hzzly/xyy-vue</a><br>4) 搭建vue2(用的gulp)： <a href="https://github.com/lzxb/vue2-demo" target="_blank" rel="noopener">https://github.com/lzxb/vue2-demo</a><br>5) vue2.0的一些文章: <a href="https://github.com/WYseven/vue2-basic-demo" target="_blank" rel="noopener">https://github.com/WYseven/vue2-basic-demo</a><br>6) 搭建vue2.0很不错的文章：<a href="https://segmentfault.com/a/1190000007630677#articleHeader7" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007630677#articleHeader7</a> {(初级搭建是根据此文章搭建的)</p><blockquote><p>后继：根据上述资料设置sass与axios:<br>npm install node-sass –save-dev<br>npm install sass-loader –save-dev<br>npm install axios —save<br>npm install vuex-router-sync —save<br>npm install eslint-friendly-formatter —save-dev<br>根据1）中axios配置http响应<br>配置 autoprefix即自动加上css前缀:<br>{<br>npm install postcss postcss-cssnext —save-dev<br>然后在vue-loader.conf.js里配置:<br>postcss: [require(‘postcss-cssnext’)()]</p></blockquote><ul><li>例如:<pre><code>module.exports = {  loaders: utils.cssLoaders({    sourceMap: isProduction      ? config.build.productionSourceMap      : config.dev.cssSourceMap,    extract: isProduction,    postcss: [require(&apos;postcss-cssnext&apos;)()]  }),  postcss:[require(&apos;postcss-px2rem&apos;)({&apos;remUnit&apos;:37.5, &apos;baseDpr&apos;: 1})],  transformToRequire: {    video: &apos;src&apos;,    source: &apos;src&apos;,    img: &apos;src&apos;,    image: &apos;xlink:href&apos;  }}</code></pre>}<br>7) vuex-router-sync: Effortlessly keep vue-router and vuex store in sync。主要是把 vue-router 的状态放进 vuex 的 state 中，这样就可以通过改变 state 來进行路由的一些操作。<br>8) vue插件机制及模板渲染: <a href="https://github.com/Cyrilszq/Cyril-Blog/issues/2" target="_blank" rel="noopener">https://github.com/Cyrilszq/Cyril-Blog/issues/2</a><br>9) postcss 与Autoprefixer的区别:<blockquote><p>~ 两者都是基于 CSS 处理框架 postcss 的（postcss 就是 Autoprefixer 的作者把 Autoprefixer 从另一个 CSS 处理框架 rework 中迁移出来时搞的）。相比之下，Autoprefixer 更加具有实用价值，而 cssnext 实现的功能以后浏览器会怎么实现还存疑，感觉只能玩玩。<br>~ cssnext: CSS 的转译器（transpiler），根据目前仍处于草案阶段、未被浏览器实现的标准把代码转译成符合目前浏览器实现的 CSS。类似 ES6 的 Babel。转译时因为也要处理前缀问题，所以直接依赖了 Autoprefixer 来做这个部分<br>~ autoprefixer 只加前缀，cssnext 依赖 autoprefixer(core) ，并附带其他功能。        </p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;插件结合搭建vue项目&quot;&gt;&lt;a href=&quot;#插件结合搭建vue项目&quot; class=&quot;headerlink&quot; title=&quot;插件结合搭建vue项目&quot;&gt;&lt;/a&gt;插件结合搭建vue项目&lt;/h3&gt;&lt;p&gt;1) axios: &lt;a href=&quot;https://github.
      
    
    </summary>
    
      <category term="vue" scheme="https://renjiansiyuetian.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://renjiansiyuetian.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>总结动画(基础篇)</title>
    <link href="https://renjiansiyuetian.github.io/2017/07/19/%E6%80%BB%E7%BB%93%E5%8A%A8%E7%94%BB(%E5%9F%BA%E7%A1%80%E7%AF%87)/"/>
    <id>https://renjiansiyuetian.github.io/2017/07/19/总结动画(基础篇)/</id>
    <published>2017-07-18T16:00:00.000Z</published>
    <updated>2018-10-30T03:15:18.847Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、过渡"><a href="#一、过渡" class="headerlink" title="一、过渡"></a>一、过渡</h3><h4 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h4><blockquote><p>transform</p><ul><li>其为变形的基础，属性能对元素对象进行变形操作，主要包括以下几种：旋转rotate、缩放scale、移动translate、倾斜skew以及矩阵变形matrix。</li></ul></blockquote><blockquote><p>translate</p><ul><li>translateZ：在Z轴移动元素，前提是元素本身或者元素的父元素设定了透视值。</li></ul></blockquote><blockquote><p>skew</p><ul><li>只是在x、y轴 倾斜，没z轴一说。</li></ul></blockquote><blockquote><p>rotate</p><ul><li>单纯的rotate旋转，正值顺时针，负值逆时针</li><li>3D旋转<pre><code>方框: | |X: 以方框x轴，从下向上旋转；Y: 以方框y轴，从左向右旋转；Z: 以方框中心为原点，顺时针旋转rotateX(a)函数功能等同于rotate3d(1,0,0,a)rotateY(a)函数功能等同于rotate3d(0,1,0,a)rotateZ(a)函数功能等同于rotate3d(0,0,1,a)注释：  a指的是一个旋转角度值。  turn是圈，1turn = 360deg；  另外还有弧度rad，2πrad = 1turn = 360deg。  如，transform:rotate(2turn); //旋转两圈</code></pre></li></ul></blockquote><blockquote><p>scale</p><ul><li>3D缩放<pre><code>缩放值在[0.01, 1)区间时，为缩小；当值大于1时，为放大。X：以方框Y轴，左右变宽；Y: 以方框X轴，上下变高;Z: 看不出变换。scale3d(1,1,sz)，其效果等同于scaleZ(sz)。注意的是scale 3D变换单独使用时，是没有效果的，需配合其它变形函数才能有效果。</code></pre></li></ul></blockquote><blockquote><p>perspective</p><ul><li>对3D变换很是重要，不然Z轴所有的点都有投射到一个平面上</li></ul></blockquote><p><strong><em>以上是2D、3D变换，变换过程的时间与速度的控制，就需要transition了。</em></strong></p><h4 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h4><blockquote><p>transition 时间与速度</p><ul><li>transition-property 控制的是哪个属性，比如:width。如果是all（也是默认值）,就是全部控制。</li><li>transition-duration 控制运行时间,如.2s</li><li>transition-timing-function 控制过渡的效果,如ease-in</li><li>transition-delay 控制延迟时间,如.1s<pre><code>综上，transition可合并2）3 ) 4) 5)使用，如transition: all .2s ease-in .1s注意:  transform-origin是可以改变变形原点，但是其影响到的变形函数只有rotate()；  transform-style决定是以2D展现，还是3D展现；  perspective-origin是定3D元素的底部位置，只能和perspective配合使用。</code></pre></li></ul></blockquote><p>二、动画</p><blockquote><ol><li>先是定义animation-name,即动画名称。其实现是通过关键字@keyframes定义的，例如:<pre><code>@keyframes test {    from { top: 0px }    to { top: 50px }}</code></pre></li><li>定义完动画，便是控制了，属性有下:</li></ol><ul><li>animation-duration: 动画时间；</li><li>animation-timing-function: 动画效果;</li><li>animation-delay: 延迟时间;</li><li>animation-iteration-count: 播放次数</li><li>animation-direction: 播放方向</li><li>animation-fill-mode: 播放停止时的状态</li><li>animation-play-state: 播放的过程中有干扰时(比如:hover)，所执行的状态        </li></ul></blockquote><blockquote><p>同过渡，animation也是可以合并简写,其简写方式为:<br>        animation: animation-name, animation-duration, animation-timing-function, animation-delay, animation-iteration-count, animation-direction 和 animation-fill-mode.          </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、过渡&quot;&gt;&lt;a href=&quot;#一、过渡&quot; class=&quot;headerlink&quot; title=&quot;一、过渡&quot;&gt;&lt;/a&gt;一、过渡&lt;/h3&gt;&lt;h4 id=&quot;transform&quot;&gt;&lt;a href=&quot;#transform&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="css" scheme="https://renjiansiyuetian.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://renjiansiyuetian.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>css 基础经常使用</title>
    <link href="https://renjiansiyuetian.github.io/2017/06/27/css-%E5%9F%BA%E7%A1%80%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8/"/>
    <id>https://renjiansiyuetian.github.io/2017/06/27/css-基础经常使用/</id>
    <published>2017-06-27T07:05:11.000Z</published>
    <updated>2018-10-30T02:38:12.240Z</updated>
    
    <content type="html"><![CDATA[<ol><li>换行省略<pre><code>overflow: hidden;text-overflow: ellipsis;white-space: nowrap;</code></pre></li><li>强制换行<pre><code>white-space: normal; //中英文都支持word-wrap: break-word; //支持英文word-break: break-all; //支持英文</code></pre></li><li>多行省略<pre><code>display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden;text-overflow: ellipsis;</code></pre></li><li>宽度已知，让高度与宽度1:1变化<pre><code>例如:.item-flex {  width: 102px;  .img-flex {    height: 0px;    padding-bottom: 100%;  }}</code></pre><blockquote><p>采用的方法是利用了padding-top/padding-bottom属性,根据他的解释,`padding’如果是百分比的话,那这个百分比是相对于其父元素的宽度而言的。</p></blockquote></li></ol><p><strong>资料:来源<a href="http://www.jianshu.com/p/56a3adebdb01/" target="_blank" rel="noopener">http://www.jianshu.com/p/56a3adebdb01/</a></strong></p><ul><li><p>而作者使用到了另一个属性overflow,另外，在计算 Overflow 时，是将元素的内容区域（即 width / height 对应的区域）和 Padding 区域一起计算的。换句话说，即使将元素的 overflow 设置为 hidden，“溢出”到 Padding 区域的内容也会照常显示。**</p></li><li><p>这样就能使用padding-top/padding-bottom来代替height属性了.比如你想要让元素的按在4:3的比例显示,width设置成了30%,那么padding-top/padding-bottom只需要设置成为<br>40%就可以了.同时把height设为0.css代码如下:</p><pre><code>.img-3-4 {  margin: 10px;  padding-bottom: 30%;  width: 40%;  height: 0;  background-color: #dbe0e4;}</code></pre><p>5.在每一个item中的图片都能按照规定的比例显示.对于image标签来说,如果是自然的显示原图片的比例</p><pre><code>.img {   display: block;   max-width: 100%;   height: auto;    }</code></pre></li></ul><p>6.flex布局:<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p><p>7.头部meta设置<a href="http://blog.csdn.net/huang100qi/article/details/42596799" target="_blank" rel="noopener">http://blog.csdn.net/huang100qi/article/details/42596799</a></p><p>8.vertical-align</p><ul><li>vertical-align对块状水平的元素是没有效果的。</li><li><p><a href="https://segmentfault.com/a/1190000002668492" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002668492</a></p><pre><code>Vertical-align被用于垂直对齐inline元素，也就是display值为inline和inline-block的元素。vertical-align基线改变：  a:普通inline-block的基线是文字内容的下边界；  b:overflow不为visible的与设置了height的，基线都为margin-box的下边界。</code></pre></li></ul><p>9.contenteditable属性兼容所有浏览器</p><pre><code>&lt;div contenteditable=“true&quot;&gt;可以编辑里面的内容&lt;/div&gt;  </code></pre><p>10.左边定宽，右边自适应</p><blockquote><p>首先，aside定宽 section不定宽度</p></blockquote><pre><code>&lt;aside&gt;left&lt;/aside&gt;&lt;section&gt;right&lt;/section&gt;</code></pre><ul><li>左边设置左浮动，右边宽度仅设置100%<pre><code>.left{ float:left; } .right{ width:100% }</code></pre></li><li>父容器设置display:flex，right部分设置flex:1<pre><code>.father { display:flex } .right {flex:1}    </code></pre></li><li>设置左右浮动，右边的浮动width为calc(100vw-200px)<pre><code>.left { float:left } .right{ float:right; width:calc(100vw-200px) }</code></pre></li><li>用负margin，页面结构：<pre><code>&lt;div class=“container”&gt;    &lt;section class=“right”&gt;right&lt;/section&gt;&lt;/div&gt;&lt;aside class=“left”&gt;    left&lt;/aside&gt;</code></pre>设置样式：<pre><code>.container { float:left; width:100%; }.right{ margin-left:200px; }.left{ float:left; margin-left:-100%; }</code></pre></li></ul><p>11.box-sizing<br>      box-sizing:content-box/border-box/inherit<br>      content-box——默认值，采用Standard box model<br>      border-box——采用IE box model<br>      inherit——继承父元素属性值</p><p>12.局部图片滑动 </p><ul><li><p>在要滑动的list img之前，加上父亲元素outer和inner。将<br>outer设置为:</p><pre><code>.outer {    position: relative;    overflow: hidden;    min-height: XX px;}.inner {    position: absolute    left: 0;    right: 0;    overflow-x: scroll;    overflow-y: hidden;}</code></pre><p>然后 list img正常设置便可。</p></li></ul><p>13.input date的兼容性问题</p><ul><li>Input date在pc端的兼容性还是比较差的，除了chrome支持以为，其它几乎都不能使用。但在移动端的兼容性还是可以的。故如若在移动端使用，还需要考虑其placeholder的兼容性，因为placeholder仅在pc端显示，在移动端是不支持的。<pre><code>解决方案：通过标签上某个属性的改变,从而仿placeholder，例如://当有值时，设置其添加class空样式: has-value,没有值时便显示placeholderinput[type=&quot;date&quot;]:not(.has-value):before {  color: grey;  content: attr(placeholder);}// 清空placeholder的条件input[readonly]:before {    content: &apos;&apos;;}</code></pre></li></ul><p>14.JPEG、PNG、SVG<br><a href="http://web.jobbole.com/91599/" target="_blank" rel="noopener">http://web.jobbole.com/91599/</a></p><blockquote><ul><li>JPEG适用于亮度与色彩压缩。</li><li>PNG对于线条图，LOGO，图标和颜色较少的图像非常适合。</li><li>SVG在线条艺术，LOGO，图标，插画和数据可视化方面用途广泛。</li></ul></blockquote><p>15.头部中部尾部布局</p><ul><li>1)头尾fixed,中部absolute<pre><code>html,body{width:100%;height:100%;position:relative;}#body-container{width:100%;height:100%;position:absolute;left:0;top:0;}#header{position:fixed;left:0;top:0;width:100%;height:49px;}#content{position:absolute;left:0;right:0;top:49px;bottom:44px;overflow-y:auto;}#footer{position:fixed;left:0;;bottom:0;width:100%;height:44px;}</code></pre></li><li>2)lex布局（仿照手机淘宝布局）<pre><code>*{margin:0;padding:0;}html,body{width:100%;height:100%;position:relative;}#body-container{width:100%;height:100%;display:flex;flex-direction:column;}#header{height:49px;flex:none;}#content{flex:1 1 auto;overflow-y:auto;}#footer{height:44px;flex:none;}</code></pre></li></ul><p>16.clearfix进化史<br><a href="http://web.jobbole.com/85965/" target="_blank" rel="noopener">http://web.jobbole.com/85965/</a></p><p>17.宽比成比例的<br>        width: 100%;<br>        height: 0px;<br>        padding-bottom: 50%;<br>        display: inline;         </p><p>18.pre换行<br>        white-space:pre-wrap;<br>        word-wrap: break-word; </p><p>19.video的坑<br><a href="http://web.jobbole.com/93251/" target="_blank" rel="noopener">http://web.jobbole.com/93251/</a></p><pre><code>&lt;video controls&gt;  source src=&quot;https://chimee.org/vod/2.webm&quot;&gt;  source src=&quot;https://chimee.org/vod/2.ogg&quot;&gt;  source src=&quot;https://chimee.org/vod/2.mp4&quot;&gt;  source src=&apos;https://chimee.org/x.myvideoext&apos; type=&apos;video/mp4; codecs=&quot;mp4v.20.8, mp4a.40.2&quot;&apos;&gt;  p&gt;当前环境不支持video标签。p&gt;&lt;/video&gt;</code></pre><p>20.杂项</p><ul><li>AA:大转盘<br><a href="http://www.daxueit.com/article/16703.html" target="_blank" rel="noopener">http://www.daxueit.com/article/16703.html</a></li><li>BB:移动端问题记录<br><a href="http://blog.csdn.net/k513492640/article/details/73997607" target="_blank" rel="noopener">http://blog.csdn.net/k513492640/article/details/73997607</a></li><li>CC:前端踩坑大杂烩<br><a href="http://www.cnblogs.com/fastmover/p/4873765.html" target="_blank" rel="noopener">http://www.cnblogs.com/fastmover/p/4873765.html</a></li><li>DD:rem<br><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651552493&amp;idx=1&amp;sn=84144094bfcbbca5c3f78907f49d4787&amp;chksm=8025ad2cb752243aa0d6975cbeaf95490810fe456f00f8562bde7aeb3366c0bbd9a4f516271f&amp;scene=0&amp;key=e4a4e74651de5963d522bfff8727ce52c074dbd253178438b52bd5b53a9a5a6d2b20704bf69eb40d56e6f71a42544927d99ef5ac2762df11bd170e348b6aa0b10e751f85db359075f67f7f014cfbf968&amp;ascene=0&amp;uin=MjY2MDUwNzgxOQ%3D%3D&amp;devicetype=iMac+MacBookPro13%2C1+OSX+OSX+10.12.3+build(16D30)&amp;version=12020810&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=2dqCIt261iAAt7GpaL0SRS%2F4Mid9NkzIn3iVdaL5FsJG2e61K0rbo5lgjkV6lkfg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651552493&amp;idx=1&amp;sn=84144094bfcbbca5c3f78907f49d4787&amp;chksm=8025ad2cb752243aa0d6975cbeaf95490810fe456f00f8562bde7aeb3366c0bbd9a4f516271f&amp;scene=0&amp;key=e4a4e74651de5963d522bfff8727ce52c074dbd253178438b52bd5b53a9a5a6d2b20704bf69eb40d56e6f71a42544927d99ef5ac2762df11bd170e348b6aa0b10e751f85db359075f67f7f014cfbf968&amp;ascene=0&amp;uin=MjY2MDUwNzgxOQ%3D%3D&amp;devicetype=iMac+MacBookPro13%2C1+OSX+OSX+10.12.3+build(16D30)&amp;version=12020810&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=2dqCIt261iAAt7GpaL0SRS%2F4Mid9NkzIn3iVdaL5FsJG2e61K0rbo5lgjkV6lkfg</a></li><li>EE: 利用视口单位实现适配<br><a href="https://aotu.io/notes/2017/04/28/2017-4-28-CSS-viewport-units/" target="_blank" rel="noopener">https://aotu.io/notes/2017/04/28/2017-4-28-CSS-viewport-units/</a>              </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;换行省略&lt;pre&gt;&lt;code&gt;overflow: hidden;
text-overflow: ellipsis;
white-space: nowrap;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;强制换行&lt;pre&gt;&lt;code&gt;white-space: n
      
    
    </summary>
    
      <category term="css" scheme="https://renjiansiyuetian.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://renjiansiyuetian.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>webFront</title>
    <link href="https://renjiansiyuetian.github.io/2017/03/13/webFront/"/>
    <id>https://renjiansiyuetian.github.io/2017/03/13/webFront/</id>
    <published>2017-03-13T06:15:22.000Z</published>
    <updated>2018-10-30T03:15:46.801Z</updated>
    
    <content type="html"><![CDATA[<p>###前端知识小结 2015~2016<br><a id="more"></a></p><ol><li><img src="/img/WebF.png" alt="webFront(2015~2016)" title="webFront(2015~2016)"></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###前端知识小结 2015~2016&lt;br&gt;
    
    </summary>
    
      <category term="webFront" scheme="https://renjiansiyuetian.github.io/categories/webFront/"/>
    
    
      <category term="webFront" scheme="https://renjiansiyuetian.github.io/tags/webFront/"/>
    
  </entry>
  
  <entry>
    <title>vue零碎小细节知识</title>
    <link href="https://renjiansiyuetian.github.io/2017/03/10/vue%E9%9B%B6%E7%A2%8E%E5%B0%8F%E7%BB%86%E8%8A%82%E7%9F%A5%E8%AF%86/"/>
    <id>https://renjiansiyuetian.github.io/2017/03/10/vue零碎小细节知识/</id>
    <published>2017-03-10T02:19:41.000Z</published>
    <updated>2018-10-30T03:16:55.978Z</updated>
    
    <content type="html"><![CDATA[<p>###细节</p><ol><li>侦测到数据变化时，DOM不会立马更新，等到异步队列被清除，也就是下一个事件循环开始时执行更新。想要数据立马更新,用<code>Vue.nextTick(callback)</code>。<a id="more"></a></li><li>v-for插值用v-text或{ {} }，v-text、v-html、{ {} }区别:</li></ol><ul><li>v-text与{ {} }都可以完成数据的渲染或插值，但是{ {} }在初期，如果数据没加载上来，会显示一些不愿用户看到的字符，但是用v-text就会等数据加载完毕时再显示，就不会出现此问题。</li><li>v-html可以解析字符串中的标签,如果是v-text就解析不了，会当做字符串识别。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###细节&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;侦测到数据变化时，DOM不会立马更新，等到异步队列被清除，也就是下一个事件循环开始时执行更新。想要数据立马更新,用&lt;code&gt;Vue.nextTick(callback)&lt;/code&gt;。
    
    </summary>
    
      <category term="vue" scheme="https://renjiansiyuetian.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://renjiansiyuetian.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue2+webpack+es6搭建简单项目</title>
    <link href="https://renjiansiyuetian.github.io/2017/03/10/vue2-webpack-es6%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E9%A1%B9%E7%9B%AE/"/>
    <id>https://renjiansiyuetian.github.io/2017/03/10/vue2-webpack-es6搭建简单项目/</id>
    <published>2017-03-10T01:28:06.000Z</published>
    <updated>2018-10-30T03:19:52.466Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在vue在出1.x的时候，就关注过它，不过那时觉得它还不是太出彩，即稳定性、可用性、持久性不是太好，还是选择了angularjs作为项目的前端技术支持。如今，vue2.0已出世，而且其也越来越受欢迎。看见热门博客里总有vue的存在，就马上觉得自己快要out了，这才决心也要好好学学它，不求多精通，至少会用些吧。</p><h2 id="在我眼里，vue-PK-angularjs"><a href="#在我眼里，vue-PK-angularjs" class="headerlink" title="在我眼里，vue PK angularjs"></a>在我眼里，vue PK angularjs</h2><a id="more"></a><h3 id="angularjs"><a href="#angularjs" class="headerlink" title="angularjs"></a>angularjs</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>强大的后台Google。追随者很多，社区活跃，有发展</li><li>改革完善第一人。html属性扩展且包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，并且是声明式的，自带了丰富的 Angular 指令</li><li>Ionic与angularjs的结合。作为一款html5混合式开发，适合开发丰富和强大的应用程序。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>太大难以下口。</li><li>1.0版本与2.0版本相差太大。</li><li>不支持IE8以下</li></ul><h3 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h3><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ul><li>简单：中文文档清晰健全，简单易学</li><li>组合灵巧：用解耦的，可复用的组件组合到应用程序里</li><li>快速：异步批处理方式更新dom</li><li>小而不拖沓：包小无依赖</li><li>小而有力：各功能项封装的很强大，供使用者轻松使用</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>后台不硬气，导致影响度不大。现今与阿里Weex合作，且越来越被大家认可，且期待吧</li><li>版本没angularjs成熟</li><li>不支持IE8</li></ul><h3 id="vue与angularjs相似处"><a href="#vue与angularjs相似处" class="headerlink" title="vue与angularjs相似处"></a>vue与angularjs相似处</h3><ul><li>双向数据绑定</li><li>相似的基础指令<h4 id="在不同的-MVVM-框架中，实现双向数据绑定的技术有所不同。"><a href="#在不同的-MVVM-框架中，实现双向数据绑定的技术有所不同。" class="headerlink" title="在不同的 MVVM 框架中，实现双向数据绑定的技术有所不同。"></a>在不同的 MVVM 框架中，实现双向数据绑定的技术有所不同。</h4></li><li>angularjs 采用“脏值检测”的方式，数据发生变更后，对于所有的数据和视图的绑定关系进行一次检测，识别是否有数据发生了改变，有变化进行处理，可能进一步引发其他数据的改变，所以这个过程可能会循环几次，一直到不再有数据变化发生后，将变更的数据发送到视图，更新页面展现。如果是手动对 ViewModel 的数据进行变更，为确保变更同步到视图，需要手动触发一次“脏值检测”。</li><li>vuejs 则使用 ES5 提供的 Object.defineProperty() 方法，监控对数据的操作，从而可以自动触发数据同步。并且，由于是在不同的数据上触发同步，可以精确的将变更发送给绑定的视图，而不是对所有的数据都执行一次检测。</li></ul><h2 id="搭建基本架构"><a href="#搭建基本架构" class="headerlink" title="搭建基本架构"></a>搭建基本架构</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>vue单页面运行也是可以的，但构建一个项目，不仅仅是用到单方面的某个技术，而是结合当下，根据需求搭配技术框架。</li><li>vue-cli是官方提供的命令行工具，可快速搭建vue项目，加速开发进度</li><li>webpack是当下最热门的前端资源模块化管理和打包工具</li><li>es6是JavaScript语言的下一代标准，vue可用es6，通过webpack解析可为目前大多数浏览器识别的js版本，不会影响项目的运行。</li></ul><h3 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h3><ul><li>在windows端，搭建node环境借助npm下载相关包，是非常方便的。所以首先下载node（npm是随同node的），node环境一旦生产，就可以使用了，我自己使用它借助的是git bash，在git bash上输入命令行，可以如在mac上一样随洒自如地操作项目。</li></ul><h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><ul><li>在命令行输入 <code>npm install -g vue-cli</code> ，全局安装vue-cli脚手架</li><li>在命令行输入 <code>vue init webpack myapp</code> ，初始化vue + webpack组合的项目构架，其中myapp为项目名</li><li>在命令行输入 <code>cd myapp</code> 然后再输入 <code>npm install</code> ，切换到项目根目录下，且安装项目根目录下package.json里面的相关依赖包</li><li>在命令行输入 <code>vue run dev</code> vue项目处于开发环境，此时访问<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> ，可看到vue已运行起来，首页为vue默认页面</li><li>至此基本构架完毕</li></ul><h3 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h3><ul><li>在vue对象建立时，有属性data、methods、watch。其中data里面的数据，可以被后两者通过this被访问。</li><li>在新建vue对象时，如果要使用自定义组件，需要先在components里面注册。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在vue在出1.x的时候，就关注过它，不过那时觉得它还不是太出彩，即稳定性、可用性、持久性不是太好，还是选择了angularjs作为项目的前端技术支持。如今，vue2.0已出世，而且其也越来越受欢迎。看见热门博客里总有vue的存在，就马上觉得自己快要out了，这才决心也要好好学学它，不求多精通，至少会用些吧。&lt;/p&gt;
&lt;h2 id=&quot;在我眼里，vue-PK-angularjs&quot;&gt;&lt;a href=&quot;#在我眼里，vue-PK-angularjs&quot; class=&quot;headerlink&quot; title=&quot;在我眼里，vue PK angularjs&quot;&gt;&lt;/a&gt;在我眼里，vue PK angularjs&lt;/h2&gt;
    
    </summary>
    
      <category term="vue" scheme="https://renjiansiyuetian.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://renjiansiyuetian.github.io/tags/vue/"/>
    
      <category term="webpack" scheme="https://renjiansiyuetian.github.io/tags/webpack/"/>
    
      <category term="es6" scheme="https://renjiansiyuetian.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>js常用小记录</title>
    <link href="https://renjiansiyuetian.github.io/2017/02/02/js%E5%B8%B8%E7%94%A8%E5%B0%8F%E8%AE%B0%E5%BD%95/"/>
    <id>https://renjiansiyuetian.github.io/2017/02/02/js常用小记录/</id>
    <published>2017-02-01T16:00:00.000Z</published>
    <updated>2018-10-30T04:18:36.952Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-自带的函数"><a href="#一-自带的函数" class="headerlink" title="一: 自带的函数"></a>一: 自带的函数</h3><p>1) split、splice、slice的区别:<br><a href="http://blog.csdn.net/zpw91/article/details/53705462" target="_blank" rel="noopener">http://blog.csdn.net/zpw91/article/details/53705462</a></p><ul><li>Split()<blockquote><p>Split是切割字符串的一种方法，该方法主要用于把一个字符串分割成字符串数组。<br>var s= ‘how do you do’;<br>var b = s.split(“ ”);//空格分割 how,do,you,do</p></blockquote></li><li>Splice () (会改变本尊数组)<blockquote><p>Splice ()方法向/从数组中添加/删除元素，然后返回被删除的元素组成的数组。用于数组对象。arr.splice(index, howmany, item1,…, itemX)<br>其中：<br>index<br>必需。整数，规定了添加/删除元素的位置，使用负数可从数组结尾处规定位置。<br>howmany<br>必需。要删除的元素的数量。如果设置为0，则不会删除元素。如果添加元素则这里应该设置为0.<br>itemX<br>可选。向数组添加的新项目。在添加的时候用。</p></blockquote></li><li>Slice()（不会改变本尊数组）<blockquote><p>slice()方法主要用于截取数组，并返回截取到的新数组。 数组和字符串对象均可以使用。 arr.slice(start, end)</p></blockquote></li></ul><p>2) scrollIntoView</p><blockquote><p>scrollIntoView(alignWithTop) 滚动浏览器窗口或容器元素，以便在当前视窗的可见范围看见当前元素。如果alignWithTop为true，或者省略它，窗口会尽可能滚动到自身顶部与元素顶部平齐。</p></blockquote><p>3) Object.keys(对象) =&gt; 判断一个对象是否为空</p><p>4)enxtype几种方式:</p><blockquote><p>application/x-www-form-urlencoded (默认，正常的提交方式)<br>multipart/form-data(有上传文件时常用这种)<br>application/json (ajax常用这种格式)<br>text/xml<br>text/plain</p></blockquote><p>5）文件上传，不经过form表单提交，可以借用h5的FormData。</p><ul><li>例如:<pre><code>const config = { headers: { &apos;Content-Type&apos;: &apos;multipart/form-data&apos; } }let fd = new FormData()fd.append(&apos;file&apos;, this.file) // this.file为上传的文件信息// fd传过去为data字段，如此post请求，便可以将文件传至后台接收this.api.postUploadAvatar(fd,  config)</code></pre></li></ul><p>6)文件上传时，本地显示:</p><blockquote><p>var src=window.URL.createObjectURL(blob)//这里传一个文件对象 例如：file.files[0]<br>img.src=src;</p></blockquote><p>7) css解决ios scroll 不流利, js解决安卓端键盘遮挡<br><a href="https://segmentfault.com/a/1190000008788147" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008788147</a></p><p>8) requestAnimationFrame</p><blockquote><p>requestAnimationFrame与setTimeout和setInterval类似，都是通过递归调用同一个方法不断更新页面。</p></blockquote><p>9）变量<br>// js核心 （提到变量）<br><a href="http://web.jobbole.com/91737/" target="_blank" rel="noopener">http://web.jobbole.com/91737/</a></p><blockquote><p>以前的作用域只有两种（如果非要加上eval()，那就是三个，即还有eval函数作用域）:全局作用域, 函数作用域（A）。<br>在还是A时，出现了一个术语，叫做“变量提升”。即var声明的变量，在作用域里执行时，会被置到最前面并赋值为undefined。如果此变量已赋值在某位置，只是在后面而已（例如: var x=2），则会再其位置处，将undefined的变量赋为其值（例如赋值为2）。</p><ul><li>es6出现后，有了let与const。let与var的区别:<br>1）let 的作用域只在其处于的块级内。<br>2）let没有所谓的“变量提升”(更精确来说，应该是提升了，不过就是不让你用，所以是为“暂时性死区”)。</li></ul></blockquote><p>10）杂项</p><ul><li>Rem<pre><code>// remlet html = document.querySelector(&apos;html&apos;)let width = html.getBoundingClientRect().widthhtml.style.fontSize = width / 10 + &apos;px&apos;</code></pre></li><li>手机端禁止缩放<pre><code>// 禁用双指缩放document.documentElement.addEventListener(&apos;touchstart&apos;, function (event) {  if (event.touches.length &gt; 1) {    event.preventDefault()  }}, false)// 禁用手指双击缩放let lastTouchEnd = 0document.documentElement.addEventListener(&apos;touchend&apos;, function (event) {  let now = Date.now()  if (now - lastTouchEnd &lt;= 300) {    event.preventDefault()  }  lastTouchEnd = now}, false)</code></pre></li><li>解决安卓端键盘遮挡:<pre><code>// inputlet u = navigator.userAgentlet isAndroid = u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Adr&apos;) &gt; -1 // android终端if (isAndroid) {  let beforeHeight = document.documentElement.clientHeight  window.addEventListener(&apos;resize&apos;, function () {    let afterHeight = document.documentElement.clientHeight    if ((beforeHeight - afterHeight) &gt; 50) {    } else {      document.getElementById(&apos;scroll&apos;).style.top = &apos;initial&apos;    }  })  window.addEventListener(&apos;focusin&apos;, function () {    document.getElementById(&apos;scroll&apos;).style.top = -50 + &apos;px&apos;  })  window.addEventListener(&apos;focusout&apos;, function () {    document.getElementById(&apos;scroll&apos;).style.top = &apos;initial&apos;  }) }</code></pre>或者，简单点：<pre><code>if (/Android/gi.test(navigator.userAgent)) {  window.addEventListener(&apos;resize&apos;, function () {    if (document.activeElement.tagName === &apos;INPUT&apos; || document.activeElement.tagName === &apos;TEXTAREA&apos;) {      window.setTimeout(function () {        // document.activeElement.scrollIntoViewIfNeeded()        document.activeElement.scrollIntoView(true)      }, 300)    }  })}</code></pre></li></ul><p>11) 关于for循环<br>1、<img src="/img/for-of.jpg" alt="js(for-of)" title="js(for-of)"><br>2、<img src="/img/for-key.jpg" alt="js(for-key)" title="js(for-key)"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-自带的函数&quot;&gt;&lt;a href=&quot;#一-自带的函数&quot; class=&quot;headerlink&quot; title=&quot;一: 自带的函数&quot;&gt;&lt;/a&gt;一: 自带的函数&lt;/h3&gt;&lt;p&gt;1) split、splice、slice的区别:&lt;br&gt;&lt;a href=&quot;http://blo
      
    
    </summary>
    
      <category term="js" scheme="https://renjiansiyuetian.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://renjiansiyuetian.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>vue与angularjs基础指令</title>
    <link href="https://renjiansiyuetian.github.io/2016/05/16/vue&amp;angularjs%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/"/>
    <id>https://renjiansiyuetian.github.io/2016/05/16/vue&amp;angularjs基础指令/</id>
    <published>2016-05-16T02:33:13.000Z</published>
    <updated>2018-10-30T03:30:00.365Z</updated>
    
    <content type="html"><![CDATA[<p>学过angularjs的同学，上手vue应该会特别简单。vue从某些方面上来说，就是简版的angularjs。</p><h2 id="基础性使用"><a href="#基础性使用" class="headerlink" title="基础性使用"></a>基础性使用</h2><a id="more"></a><h3 id="基础指令相比较"><a href="#基础指令相比较" class="headerlink" title="基础指令相比较"></a>基础指令相比较</h3><table><thead><tr><th>vue</th><th style="text-align:center">angularjs</th><th style="text-align:right">作用</th><th>使用是否相同</th><th>不同点</th></tr></thead><tbody><tr><td>v-if</td><td style="text-align:center">ng-if</td><td style="text-align:right">条件渲染指令(满足条件才会渲染在html里)</td><td>相同</td><td>无</td></tr><tr><td>v-show</td><td style="text-align:center">ng-show</td><td style="text-align:right">条件渲染指令(始终会渲染在html里)</td><td>相同</td><td>无</td></tr><tr><td>v-model</td><td style="text-align:center">ng-model</td><td style="text-align:right">双向数据绑定</td><td>相同</td><td>无</td></tr><tr><td>v-else</td><td style="text-align:center">无</td><td style="text-align:right">必须跟在v-if或者v-show的后面</td><td>不</td><td>angularjs无ng-else</td></tr><tr><td>v-for</td><td style="text-align:center">ng-repeat</td><td style="text-align:right">基于一个数组渲染一个列表</td><td>相同</td><td>无</td></tr><tr><td>v-bind</td><td style="text-align:center">ng-bind</td><td style="text-align:right">前者用于响应地更新html特性后者为单向数据绑定</td><td>不同</td><td>前者主要用于属性绑定，为真者绑定其值如:<code>&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;</code></td></tr><tr><td>v-on</td><td style="text-align:center">ng-click</td><td style="text-align:right">作用一样，用法不一样。v-on的用法与v-bind相似</td><td>不同</td><td>前者例子:<code>&lt;button v-on:click=&quot;say(&#39;Hi&#39;)&quot;&gt;Hi&lt;/button&gt;</code></td></tr></tbody></table><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li>v-bind和v-on<br>v-bind指令可以缩写为一个冒号，v-on指令可以缩写为@符号。<br>完整语法:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"javascripit:void(0)"</span> v-bind:class=<span class="string">"activeNumber === n + 1 ? 'active' : ''"</span>&gt;&#123;&#123; n + 1 &#125;&#125;&lt;/a&gt;</span><br></pre></td></tr></table></figure></li></ul><p>缩写语法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"javascripit:void(0)"</span> :class=<span class="string">"activeNumber=== n + 1 ? 'active' : ''"</span>&gt;&#123;&#123; n + 1 &#125;&#125;&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><p>完整语法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:click=<span class="string">"greet"</span>&gt;Greet&lt;/button&gt;</span><br></pre></td></tr></table></figure></p><p>缩写语法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=<span class="string">"greet"</span>&gt;Greet&lt;/button&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学过angularjs的同学，上手vue应该会特别简单。vue从某些方面上来说，就是简版的angularjs。&lt;/p&gt;
&lt;h2 id=&quot;基础性使用&quot;&gt;&lt;a href=&quot;#基础性使用&quot; class=&quot;headerlink&quot; title=&quot;基础性使用&quot;&gt;&lt;/a&gt;基础性使用&lt;/h2&gt;
    
    </summary>
    
      <category term="js框架杂烩" scheme="https://renjiansiyuetian.github.io/categories/js%E6%A1%86%E6%9E%B6%E6%9D%82%E7%83%A9/"/>
    
    
      <category term="vue" scheme="https://renjiansiyuetian.github.io/tags/vue/"/>
    
      <category term="angular.js" scheme="https://renjiansiyuetian.github.io/tags/angular-js/"/>
    
  </entry>
  
  <entry>
    <title>css 基础经常使用</title>
    <link href="https://renjiansiyuetian.github.io/2015/09/22/git-%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8/"/>
    <id>https://renjiansiyuetian.github.io/2015/09/22/git-经常使用/</id>
    <published>2015-09-21T16:00:00.000Z</published>
    <updated>2018-10-30T03:35:55.120Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、实用率高"><a href="#一、实用率高" class="headerlink" title="一、实用率高"></a>一、实用率高</h3><ul><li>端口占用，更换端口<blockquote><p>hexo server -p 5555</p></blockquote></li><li>端口占用，杀死进程<blockquote><p>查看：ps -ef|grep 4000<br>查看相关进程并杀死：kill -9 进程号</p></blockquote></li><li>本地初始化git<blockquote><p>git init<br>git add.<br>git commit -m ‘first commit’<br>git status</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、实用率高&quot;&gt;&lt;a href=&quot;#一、实用率高&quot; class=&quot;headerlink&quot; title=&quot;一、实用率高&quot;&gt;&lt;/a&gt;一、实用率高&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;端口占用，更换端口&lt;blockquote&gt;
&lt;p&gt;hexo server -p 5555&lt;/p&gt;
      
    
    </summary>
    
      <category term="git" scheme="https://renjiansiyuetian.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://renjiansiyuetian.github.io/tags/git/"/>
    
  </entry>
  
</feed>
